{"version":3,"file":"notifier-container.component.js","sourceRoot":"","sources":["notifier-container.component.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnDestroy, OnInit } from '@angular/core';\n\nimport { Subscription } from 'rxjs';\n\nimport { NotifierAction } from './../models/notifier-action.model';\nimport { NotifierConfig } from './../models/notifier-config.model';\nimport { NotifierNotification } from './../models/notifier-notification.model';\nimport { NotifierQueueService } from './../services/notifier-queue.service';\nimport { NotifierService } from './../services/notifier.service';\nimport { NotifierNotificationComponent } from './notifier-notification.component';\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n@Component({\n    changeDetection: ChangeDetectionStrategy.OnPush, // (#perfmatters)\n    host: {\n        class: 'notifier__container'\n    },\n    selector: 'notifier-container',\n    template: '<ul><li *ngFor=\"let notification of notifications; trackBy: identifyNotification;\" class=\"notifier__container-list\"><notifier-notification (dismiss)=\"onNotificationDismiss( $event )\" (ready)=\"onNotificationReady( $event )\" [notification]=\"notification\"></notifier-notification></ul>'\n})\nexport class NotifierContainerComponent implements OnDestroy, OnInit {\n\n\t/**\n\t * List of currently somewhat active notifications\n\t */\n    public notifications: Array<NotifierNotification>;\n\n\t/**\n\t * Change detector\n\t */\n    private readonly changeDetector: ChangeDetectorRef;\n\n\t/**\n\t * Notifier queue service\n\t */\n    private readonly queueService: NotifierQueueService;\n\n\t/**\n\t * Notifier configuration\n\t */\n    private readonly config: NotifierConfig;\n\n\t/**\n\t * Queue service observable subscription (saved for cleanup)\n\t */\n    private queueServiceSubscription: Subscription;\n\n\t/**\n\t * Promise resolve function reference, temporarily used while the notification child component gets created\n\t */\n    private tempPromiseResolver: () => void;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param changeDetector       Change detector, used for manually triggering change detection runs\n\t * @param notifierQueueService Notifier queue service\n\t * @param notifierService      Notifier service\n\t */\n    public constructor(changeDetector: ChangeDetectorRef, notifierQueueService: NotifierQueueService, notifierService: NotifierService) {\n        this.changeDetector = changeDetector;\n        this.queueService = notifierQueueService;\n        this.config = notifierService.getConfig();\n        this.notifications = [];\n    }\n\n\t/**\n\t * Component initialization lifecycle hook, connects this component to the action queue, and then handles incoming actions\n\t */\n    public ngOnInit(): void {\n        this.queueServiceSubscription = this.queueService.actionStream.subscribe((action: NotifierAction) => {\n            this.handleAction(action).then(() => {\n                this.queueService.continue();\n            });\n        });\n    }\n\n\t/**\n\t * Component destroyment lifecycle hook, cleans up the observable subsciption\n\t */\n    public ngOnDestroy(): void {\n        if (this.queueServiceSubscription) {\n            this.queueServiceSubscription.unsubscribe();\n        }\n    }\n\n\t/**\n\t * Notification identifier, used as the ngFor trackby function\n\t *\n\t * @param   index        Index\n\t * @param   notification Notifier notification\n\t * @returns Notification ID as the unique identnfier\n\t */\n    public identifyNotification(index: number, notification: NotifierNotification): string {\n        return notification.id;\n    }\n\n\t/**\n\t * Event handler, handles clicks on notification dismiss buttons\n\t *\n\t * @param notificationId ID of the notification to dismiss\n\t */\n    public onNotificationDismiss(notificationId: string): void {\n        this.queueService.push({\n            payload: notificationId,\n            type: 'HIDE'\n        });\n    }\n\n\t/**\n\t * Event handler, handles notification ready events\n\t *\n\t * @param notificationComponent Notification component reference\n\t */\n    public onNotificationReady(notificationComponent: NotifierNotificationComponent): void {\n        let currentNotification: NotifierNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n        currentNotification.component = notificationComponent; // Save the new omponent reference\n        this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n\n\t/**\n\t * Handle incoming actions by mapping action types to methods, and then running them\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleAction(action: NotifierAction): Promise<undefined> {\n        switch (action.type) { // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n            case 'SHOW':\n                return this.handleShowAction(action);\n            case 'HIDE':\n                return this.handleHideAction(action);\n            case 'HIDE_OLDEST':\n                return this.handleHideOldestAction(action);\n            case 'HIDE_NEWEST':\n                return this.handleHideNewestAction(action);\n            case 'HIDE_ALL':\n                return this.handleHideAllAction(action);\n            default:\n                return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                    resolve(); // Ignore unknown action types\n                });\n        }\n    }\n\n\t/**\n\t * Show a new notification\n\t *\n\t * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleShowAction(action: NotifierAction): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n            this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n            this.addNotificationToList(new NotifierNotification(action.payload));\n        });\n    }\n\n\t/**\n\t * Continue to show a new notification (after the notification components is initialized / created / rendered).\n\t *\n\t * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n\t * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n\t * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n\t * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n\t *\n\t * @param notification New notification to show\n\t */\n    private continueHandleShowAction(notification: NotifierNotification): void {\n\n        // First (which means only one) notification in the list?\n        const numberOfNotifications: number = this.notifications.length;\n        if (numberOfNotifications === 1) {\n            notification.component.show().then(this.tempPromiseResolver); // Done\n        } else {\n\n            const implicitStackingLimit: number = 2;\n\n            // Stacking enabled? (stacking value below 2 means stacking is disabled)\n            if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n                this.notifications[0].component.hide().then(() => {\n                    this.removeNotificationFromList(this.notifications[0]);\n                    notification.component.show().then(this.tempPromiseResolver); // Done\n                });\n            } else {\n\n                const stepPromises: Array<Promise<undefined>> = [];\n\n                // Are there now too many notifications?\n                if (numberOfNotifications > this.config.behaviour.stacking) {\n\n                    const oldNotifications: Array<NotifierNotification> = this.notifications.slice(1, numberOfNotifications - 1);\n\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.notifications[0].component.hide());\n                            setTimeout(() => {\n                                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            }, this.config.animations.hide.speed - this.config.animations.overlap);\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n                        } else {\n                            stepPromises.push(new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                                this.notifications[0].component.hide().then(() => {\n                                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                        notification.component.show().then(resolve);\n                                    });\n                                });\n                            }));\n                        }\n\n                    } else {\n                        stepPromises.push(this.notifications[0].component.hide());\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n\n                } else {\n\n                    const oldNotifications: Array<NotifierNotification> = this.notifications.slice(0, numberOfNotifications - 1);\n\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.shift.speed - this.config.animations.overlap);\n                        } else {\n                            stepPromises.push(new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                                this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                    notification.component.show().then(resolve);\n                                });\n                            }));\n                        }\n\n                    } else {\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n\n                }\n\n                Promise.all(stepPromises).then(() => {\n                    if (numberOfNotifications > this.config.behaviour.stacking) {\n                        this.removeNotificationFromList(this.notifications[0]);\n                    }\n                    this.tempPromiseResolver();\n                }); // Done\n\n            }\n\n        }\n\n    }\n\n\t/**\n\t * Hide an existing notification\n\t *\n\t * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n\t * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n\t * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n\t *\n\t * @param   action Action object, payload contains the notification ID\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideAction(action: NotifierAction): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            const stepPromises: Array<Promise<undefined>> = [];\n\n            // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n            const notification: NotifierNotification | undefined = this.findNotificationById(action.payload);\n            if (notification === undefined) {\n                resolve();\n                return;\n            }\n\n            // Get older notifications\n            const notificationIndex: number | undefined = this.findNotificationIndexById(action.payload);\n            if (notificationIndex === undefined) {\n                resolve();\n                return;\n            }\n            const oldNotifications: Array<NotifierNotification> = this.notifications.slice(0, notificationIndex);\n\n            // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n            if (oldNotifications.length > 0) {\n\n                // Are animations enabled?\n                if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n\n                    // Is animation overlap enabled?\n                    if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                        stepPromises.push(notification.component.hide());\n                        setTimeout(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        }, this.config.animations.hide.speed - this.config.animations.overlap);\n                    } else {\n                        notification.component.hide().then(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        });\n                    }\n                } else {\n                    stepPromises.push(notification.component.hide());\n                    stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                }\n\n            } else {\n\n                stepPromises.push(notification.component.hide());\n\n            }\n\n            // Wait until both hiding and shifting is done, then remove the notification from the list\n            Promise.all(stepPromises).then(() => {\n                this.removeNotificationFromList(notification);\n                resolve(); // Done\n            });\n\n        });\n\n    }\n\n\t/**\n\t * Hide the oldest notification (bridge to handleHideAction)\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideOldestAction(action: NotifierAction): Promise<undefined> {\n\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                resolve();\n            }); // Done\n        } else {\n            action.payload = this.notifications[0].id;\n            return this.handleHideAction(action);\n        }\n\n    }\n\n\t/**\n\t * Hide the newest notification (bridge to handleHideAction)\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideNewestAction(action: NotifierAction): Promise<undefined> {\n\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n                resolve();\n            }); // Done\n        } else {\n            action.payload = this.notifications[this.notifications.length - 1].id;\n            return this.handleHideAction(action);\n        }\n\n    }\n\n\t/**\n\t * Hide all notifications at once\n\t *\n\t * @param   action Action object\n\t * @returns Promise, resolved when done\n\t */\n    private handleHideAllAction(action: NotifierAction): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            // Are there any notifications? (prevent accidential errors)\n            const numberOfNotifications: number = this.notifications.length;\n            if (numberOfNotifications === 0) {\n                resolve(); // Done\n                return;\n            }\n\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false &&\n                this.config.animations.hide.offset > 0) {\n\n                for (let i: number = numberOfNotifications - 1; i >= 0; i--) {\n                    const animationOffset: number = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n                    setTimeout(() => {\n                        this.notifications[i].component.hide().then(() => {\n\n                            // Are we done here, was this the last notification to be hidden?\n                            if ((this.config.position.vertical.position === 'top' && i === 0) ||\n                                (this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1)) {\n                                this.removeAllNotificationsFromList();\n                                resolve(); // Done\n                            }\n\n                        });\n                    }, this.config.animations.hide.offset * animationOffset);\n                }\n\n            } else {\n\n                let stepPromises: Array<Promise<undefined>> = [];\n                for (let i: number = numberOfNotifications - 1; i >= 0; i--) {\n                    stepPromises.push(this.notifications[i].component.hide());\n                }\n                Promise.all(stepPromises).then(() => {\n                    this.removeAllNotificationsFromList();\n                    resolve(); // Done\n                });\n\n            }\n\n        });\n    }\n\n\t/**\n\t * Shift multiple notifications at once\n\t *\n\t * @param   notifications List containing the notifications to be shifted\n\t * @param   distance      Distance to shift (in px)\n\t * @param   toMakePlace   Flag, defining in which direciton to shift\n\t * @returns Promise, resolved when done\n\t */\n    private shiftNotifications(notifications: Array<NotifierNotification>, distance: number, toMakePlace: boolean): Promise<undefined> {\n        return new Promise<undefined>((resolve: () => void, reject: () => void) => {\n\n            // Are there any notifications to shift?\n            if (notifications.length === 0) {\n                resolve();\n                return;\n            }\n\n            let notificationPromises: Array<Promise<undefined>> = [];\n            for (let i: number = notifications.length - 1; i >= 0; i--) {\n                notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n            }\n            Promise.all(notificationPromises).then(resolve); // Done\n\n        });\n    }\n\n\t/**\n\t * Add a new notification to the list of notifications (triggers change detection)\n\t *\n\t * @param notification Notification to add to the list of notifications\n\t */\n    private addNotificationToList(notification: NotifierNotification): void {\n        this.notifications.push(notification);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n\n\t/**\n\t * Remove an existing notification from the list of notifications (triggers change detection)\n\t *\n\t * @param notification Notification to be removed from the list of notifications\n\t */\n    private removeNotificationFromList(notification: NotifierNotification): void {\n        this.notifications =\n            this.notifications.filter((item: NotifierNotification) => item.component !== notification.component);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n\n\t/**\n\t * Remove all notifications from the list (triggers change detection)\n\t */\n    private removeAllNotificationsFromList(): void {\n        this.notifications = [];\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n\n\t/**\n\t * Helper: Find a notification in the notification list by a given notification ID\n\t *\n\t * @param   notificationId Notification ID, used for finding notification\n\t * @returns Notification, undefined if not found\n\t */\n    private findNotificationById(notificationId: string): NotifierNotification | undefined {\n        return this.notifications.find((currentNotification: NotifierNotification) => currentNotification.id === notificationId);\n    }\n\n\t/**\n\t * Helper: Find a notification's index by a given notification ID\n\t *\n\t * @param   notificationId Notification ID, used for finding a notification's index\n\t * @returns Notification index, undefined if not found\n\t */\n    private findNotificationIndexById(notificationId: string): number | undefined {\n        const notificationIndex: number =\n            this.notifications.findIndex((currentNotification: NotifierNotification) => currentNotification.id === notificationId);\n        return (notificationIndex !== -1 ? notificationIndex : undefined);\n    }\n\n}\n"]}