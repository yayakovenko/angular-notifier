{"version":3,"file":"notifier-queue.service.js","sourceRoot":"","sources":["notifier-queue.service.ts"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAE3C,OAAO,EAAE,OAAO,EAAE,MAAM,MAAM,CAAC;;;;;;;;;;;;;;QAqCvB,IAAI,CAAC,YAAY,GAAG,IAAI,OAAO,EAAkB,CAAC;QAClD,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QACtB,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;;;;;;;;IAQ7B,mCAAI;;;;;;cAAC,MAAsB;QAC9B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,IAAI,CAAC,kBAAkB,EAAE,CAAC;;;;;;IAMvB,uCAAQ;;;;;QACX,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;QAChC,IAAI,CAAC,kBAAkB,EAAE,CAAC;;;;;;IAMtB,iDAAkB;;;;;QACtB,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3D,MAAM,CAAC;SACV;QACD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAC/B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC;;;gBArDxD,UAAU;;;;+BAjBX;;SAkBa,oBAAoB","sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { Subject } from 'rxjs';\n\nimport { NotifierAction } from './../models/notifier-action.model';\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n@Injectable()\nexport class NotifierQueueService {\n\n\t/**\n\t * Stream of actions, subscribable from outside\n\t */\n    public readonly actionStream: Subject<NotifierAction>;\n\n\t/**\n\t * Queue of actions\n\t */\n    private actionQueue: Array<NotifierAction>;\n\n\t/**\n\t * Flag, true if some action is currently in progress\n\t */\n    private isActionInProgress: boolean;\n\n\t/**\n\t * Constructor\n\t */\n    public constructor() {\n        this.actionStream = new Subject<NotifierAction>();\n        this.actionQueue = [];\n        this.isActionInProgress = false;\n    }\n\n\t/**\n\t * Push a new action to the queue, and try to run it\n\t *\n\t * @param action Action object\n\t */\n    public push(action: NotifierAction): void {\n        this.actionQueue.push(action);\n        this.tryToRunNextAction();\n    }\n\n\t/**\n\t * Continue with the next action (called when the current action is finished)\n\t */\n    public continue(): void {\n        this.isActionInProgress = false;\n        this.tryToRunNextAction();\n    }\n\n\t/**\n\t * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n\t */\n    private tryToRunNextAction(): void {\n        if (this.isActionInProgress || this.actionQueue.length === 0) {\n            return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n        }\n        this.isActionInProgress = true;\n        this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n    }\n\n}\n"]}